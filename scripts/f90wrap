#!/usr/bin/env python

# HF XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# HF X
# HF X   f90wrap: F90 to Python interface generator with derived type support
# HF X
# HF X   Copyright James Kermode 2011
# HF X
# HF X   These portions of the source code are released under the GNU General
# HF X   Public License, version 2, http://www.gnu.org/copyleft/gpl.html
# HF X
# HF X   If you would like to license the source code under different terms,
# HF X   please contact James Kermode, james.kermode@gmail.com
# HF X
# HF X   When using this software, please cite the following reference:
# HF X
# HF X   http://www.jrkermode.co.uk/f90wrap
# HF X
# HF XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

import optparse
from f90wrap.parser import read_files
from f90wrap.fortran import find_types, walk_modules, walk_procedures
from f90wrap.wrapgen import transform_to_f90_wrapper
import logging

p = optparse.OptionParser(usage='%prog [options] <input file>...')

p.add_option('-p', '--prefix', action='store',
             help="""Prefix to prepend to arguments and subroutines.""",
             default='f90wrap_')
p.add_option('-c', '--callback', action='append',
             help="""Callback routines.""")
p.add_option('-k', '--kind', action='append',
             help="""Fortran kind declarations to use in each wrapper.""")
p.add_option('-i', '--init', action='append',
             help="""Special initialisation lines used when constructing a particular type.""")
p.add_option('-v', '--verbose', action='store_true',
             help="""Enable verbose mode, with debug-level logging output.""")
p.add_option("--only", nargs="*", help="MODULE NAMES to include in wrapper")
p.add_option("--skip", nargs="*", help="MODULE NAMES to exclude from wrapper")

opt, args = p.parse_args()
tree = read_files(args)

# ## TODO -- parse opt.callback, opt.kind, opt.init to populate these lists
callbacks = []
kinds = []  # [('system_module', ('dp',))]
init_lines = {}  # {'atoms': ('atoms_module', ('if (associated(%(PTR)s)) call atoms_repoint(%(PTR)s)',
              #                            'if (present(%(ARG)s)) call atoms_repoint(%(PTR)s)'))}

if opt.verbose:
    logging.root.setLevel(logging.DEBUG)

constructors = ('initialise_ptr', 'initialise', 'allocate')
destructors = ('finalise',)
short_names = {}

string_lengths = {
    'key_len':256,
    'value_len':1024,
    'value_length':1023,
    'field_length':1023,
    'string_length':1023,
    'table_string_length':10,
    'dict_char_a_len': 10
}
default_string_length = 1024

sizeof_fortran_t = 4  # FIXME should be autodetected, as is done in QUIP/utility_scripts/find_sizeof_fortran_t

types = find_types(tree)

# We want to wrap only subroutines provided by the user (from any module),
# and only types IN MODULES WITH SUBROUTINES PROVIDED BY USER (OR THOSE REF'D BY THEM).
kept_subs = []
kept_mods = set()
if args.only:
    for mod, sub, args in walk_procedures(tree):
        if sub.name in args.only:
            kept_subs.extend([sub.name])
            kept_mods.add(mod)
elif args.skip:
    for mod, sub, args in walk_procedures(tree):
        if sub.name not in args.only:
            kept_subs.extend([sub.name])
            kept_mods.add(mod)

# Get used types now
kept_types = set()
for mod in kept_mods:
    for t in mod.types:
        kept_types.add(t)

# kept_types is now all types defined directly in kept_mods. But we also
# need those referenced by them.
new_set = kept_types
while new_set != set():
    for t in new_set:
        for el in t.elements:
            if el.type.startswith('type'):  # a referenced type, need to find def
                for mod2 in walk_modules(tree):
                    for mt in mod2.types:
                        if mt.name in el.type:
                            new_set.add(mt)
    # take out all the original types from new_set
    new_set.difference_update(kept_types)
    # update the kept_types with new ones
    kept_types.update(new_set)

tree = transform_to_f90_wrapper(tree, types, kinds, callbacks,
                                constructors, destructors,
                                short_names, init_lines,
                                string_lengths,
                                default_string_length,
                                sizeof_fortran_t=sizeof_fortran_t,
                                only_subs=kept_subs,
                                only_types=kept_types)

F90WrapperGenerator(opt.prefix).visit(tree)

